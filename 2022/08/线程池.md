# 线程池

## 一、使用原因

**降低资源的消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。

**提高响应速度**： 因为线程池中的线程数没有超过线程池的最大上限时，有的线程处于等待分配任务的状态，当任务来时无需创建新的线程就能执行。

**提高线程的可管理性**：无限的创建和销毁线程，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。

## 二、七大参数

- `corePoolSize`：池中一直保持的线程的数量，即使线程空闲。除非设置了 allowCoreThreadTimeOut 。
- `maximumPoolSize`：池中允许的最大的线程数。
- `keepAliveTime`：当线程数大于核心线程数的时候，线程在最大多长时间没有接到新任务就会终止释放， 最终线程池维持在 corePoolSize 大小。
- `unit`：时间单位。
- `workQueue`：阻塞队列，用来存储等待执行的任务，如果当前对线程的需求超过了 corePoolSize 大小，就会放在这里等待空闲线程执行。
- `threadFactory`：创建线程的工厂，比如指定线程名等。
- `handler`：拒绝策略，如果线程满了，线程池就会使用拒绝策略。

![2022-08-31_103905](https://img.qinweizhao.com/2022/08/2022-08-31_103905.png)

## 三、运行流程

 1、线程池创建，准备好 core 数量的核心线程，准备接受任务。

 2、新的任务进来，用 core 准备好的空闲线程执行。

1. core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队列获取任务执行。
2. 阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量。
3. max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自动销毁。最终保持到 core 大小。
4. 如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策略进行处理 。

3、所有的线程创建都是由指定的 factory 创建的。

## 四、模拟场景

问：一个线程池 core 7； max 20 ，queue：50，100 并发进来怎么分配的？

答：先有 7 个能直接得到执行，接下来 50 个进入队列排队，在多开 13 个继续执行。现在 70 个 被安排上了。剩下 30 个默认拒绝策略。

## 五、常见的线程池

`newCachedThreadPool` ：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

`newFixedThreadPool` ：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

`newScheduledThreadPool` ： 创建一个定长线程池，支持定时及周期性任务执行。

`newSingleThreadExecutor`：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。

