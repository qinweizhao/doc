# MySQL-事务

## 一、特性

**事务的四大特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），简称 ACID。**

原子性：事务中所有操作要么全部成功，要么全部失败。

一致性：事务执行前后，数据始终处于一致性状态，不会出现数据丢失。

隔离性：指事务提交前的中间状态对其他事务不可见，即相互隔离。

持久性：事务提交后，数据的修改永久保存在数据库中。

## 二、底层实现

**原子性是 undo log 实现的，一致性是由代码逻辑层面保证的，隔离性是由 mvcc 实现的，持久性是基于 redo log 实现的。**

### 1、Redo Log（重做日志）

Redo Log 记录的是物理日志，也就是磁盘数据的修改。用来保证服务崩溃后，仍能把事务中变更的数据持久化到磁盘上。

如果没有 Redo Log 的话，修改数据的过程为：

1. 从磁盘加载数据到内存。
2. 在内存中修改数据。
3. 把新数据持久化到磁盘。

![2022-06-30_140614](https://img.qinweizhao.com/2022/06/2022-06-30_140614.png)

这样做，会有严重的性能问题：

1. InnoDB 在磁盘中存储的基本单元是页，可能本次修改只变更一页中几个字节，但是需要刷新整页的数据，就很浪费资源。
2. 一个事务可能修改了多页中的数据，页之间又是不连续的，就会产生随机 IO，性能更差。

所以为了提高写入性能，于是就引入了 Redo Log。

引入 Redo Log 后，修改数据的过程为：

1. 从磁盘加载数据到内存。
2. 在内存中修改数据。
3. 把新数据写到 **Redo Log Buffer** 中。
4. 把 **Redo Log Buffer** 中数据持久化到 **Redo Log** 文件中。
5. 把 **Redo Log** 文件中数据持久化到数据库磁盘中。

![2022-06-30_141311](https://img.qinweizhao.com/2022/06/2022-06-30_141311.png)

### 2、Undo Log（回滚日志）

Undo Log 记录的是逻辑日志，用来回滚事务时，恢复到修改前的数据。

比如：当我们执行一条 insert 语句时，Undo Log 就记录一条相反的 delete 语句。

加入 Undo Log 之后的修改流程为：

![2022-06-30_141614](https://img.qinweizhao.com/2022/06/2022-06-30_141614.png)

### 3、MVCC（多版本并发控制）

记录的是某个时间点上的数据快照，用来实现不同事务之间数据的隔离性。

SQL 标准定义了**四个隔离级别**：

**Read UnCommitted（读未提交）：** 读到其他事务未提交的数据，会出现脏读、不可重复读、幻读。

**Read Committed（读已提交）：** 读到其他事务已提交的数据，解决了脏读，会出现不可重复读、幻读。

**Repeatable Read（可重复读）：** 相同的数据，多次读取到的结果集一致。解决了脏读和不可重复读，还是会出现幻读。

**Serializable（串行化）：** 所有事务串行执行，解决了脏读、不可重复读以及幻读。

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| Read UnCommitted |  √   |     √      |  √   |
|  Read Committed  |  x   |     √      |  √   |
| Repeatable Read  |  x   |     x      |  √   |
|   Serializable   |  x   |     x      |  x   |

MySQL InnoDB 存储引擎的默认支持的隔离级别是可重复读。可以通过 `SELECT @@tx_isolation;` 查看。

MVCC 解决了读写冲突，实现了读写并行，提升了事务的性能。

由于 Read UnCommitted 隔离级别下，每次都读取最新的数据。而 Serializable 隔离级别下，对所有读取数据都加锁。这两种隔离级不需要 MVCC，所以 MVCC 只在 Read Committed 和 Repeatable Read 两种隔离级别下起作用。

MVCC 的实现方式通过两个隐藏列 trx_id（最近一次提交事务的ID）和 roll_pointer（上个版本的地址），建立一个版本链。并在事务中读取的时候生成一个 ReadView（读视图），在 Read Committed 隔离级别下，每次读取都会生成一个读视图，而在 Repeatable Read 隔离级别下，只会在第一次读取时生成一个读视图。

![2022-06-30_144327](https://img.qinweizhao.com/2022/06/2022-06-30_144327.png)

InnoDB 如何解决幻读的？

先普及一下快照读和当前读。

**当前读：** 读取数据的最新版本，并对数据进行加锁。

例如：insert、update、delete、select for update

**快照读：** 读取数据的历史版本，不对数据加锁。

例如：select

在当前读的情况下，是通过加锁来解决幻读。

在快照读的情况下，是通过 MVCC 来解决幻读。
