# JVM-体系结构

> JVM 是 Java Virtual Machine（Java 虚拟机）的缩写。
>
> Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。
>
> **特点：**
>
> 1.  一次编译，到处运行
> 2.  自动内存管理
> 3.  自动垃圾回收功能

## 一、基本组成

- 指令集：JVM 指令集。
- 类加载器：在 JVM 启动时或者类在运行时将需要的 class 加载到 JVM 中。
- 执行引擎：负责执行 class 文件中的字节码指令，相当于 CPU。
- 运行时数据区：将内存划分成若干个区，分别完成不同的任务。
- 本地方法区：调用 C 或 C++ 实现的本地方法代码返回的结果。


## 二、内存结构

### 1、英文

![2022-03-30_215420](https://img.qinweizhao.com/2022/03/2022-03-30_215449.jpg)

### 2、中文

![2022-03-30_215420](https://img.qinweizhao.com/2022/03/2022-03-30_215420.jpg)

## 三、架构模型

Java 编译器输入的指令流基本上是一种**基于栈的指令集架构**，所有的操作数必须先入栈，然后根据指令的操作码选择从栈顶弹出若干个元素进行计算后再将结果入栈。JVM 操作数可以存放在每一个栈帧中的一个本地变量中，即每个方法调用时就会给这个方法分配一个本地变量集，这个本地变量集在编译时就已经确定，所以操作数入栈可以直接是常量或者从本地变量集中娶一个变量压入栈中。

  JVM 基于栈的设计理由是：

- JVM要设计成与平台无关的，而平台无关性就要保证在没有或者由很少的寄存器的机器上也能同样正确执行 java 代码，因为寄存器很难做到通用。
- 基于栈的理由是为 JVM 更好地优化代码而设计的。
- 为了指令的紧凑性，因为 java 代码可能在网络上传输，所以 class 文件的大小也是设计 JVM 字节码指令的一个重要因素。

### 1、基于栈

基于栈式架构的特点：

1.  设计和实现更简单，适用于资源受限的系统。
2.  避开了寄存器的分配难题：使用零地址指令方式分配。
3.  指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
4.  不需要硬件支持，可移植性更好，更好实现跨平台。

### 2、基于寄存器

基于寄存器架构的特点：

1.  典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。
2.  指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差。
3.  性能优秀和执行更高效。
4.  花费更少的指令去完成一项操作。
5.  在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。

### 3、两种架构的举例

同样执行2+3这种逻辑操作，其指令分别如下：

* **基于栈的计算流程（以 Java 虚拟机为例）：**

  ```java
  iconst_2 //常量2入栈
  istore_1
  iconst_3 // 常量3入栈
  istore_2
  iload_1
  iload_2
  iadd //常量2/3出栈，执行相加
  istore_0 // 结果5入栈
  ```

  **8个指令**

* **而基于寄存器的计算流程**

  ```java
  mov eax,2 //将eax寄存器的值设为1
  add eax,3 //使eax寄存器的值加3
  ```

  **2个指令**
