# 缓存

为了系统性能的提升，一般都会将部分数据放入缓存中，加速访问。而 db 承担数据落盘工作。

## 一、使用

适合放入缓存的数据：

- 即时性、数据一致性要求不高的
- 访问量大且更新频率不高的数据（读多，写少）

### 1、读模式

![2022-05-16_012508](https://img.qinweizhao.com/2022/05/2022-05-16_012508.png)

伪代码：

```java
// 从缓存加载数据 
data = cache.load(id);
If(data == null){
  // 从数据库加载数据
  data = db.load(id);
  // 保存到 cache 中
  cache.put(id,data);
} 
return data;
```

**注意：**

在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。

### 2、写模式

两种方案：

- 双写模式：当数据更新，重写写入缓存。
- 失效模式：当数据更新，删除缓存（下次读缓存时，不存在时去查询数据库）。

## 二、缓存失效

大并发读情况下的缓存失效问题

### 1、缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

**解决：**

- 缓存空结果、并且设置短的过期时间。

- 布隆过滤器

### 2、缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。

**解决：** 

原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

### 3、缓存击穿

对于一些设置了过期时间的 key， 如果这些 key 可能会在某些时间点被超高并发地访问， 是一种非常“热点”的数据。 这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所有对这个 key 的数据查询都落到 db， 我们称为缓存击穿。

**解决：**

加锁

## 三、数据一致性

大并发写情况下的缓存数据一致性问题

### 1、双写模式

![2022-05-16_015443](https://img.qinweizhao.com/2022/05/2022-05-16_015443.png)

当两个线程同时去写数据库，1 号线程虽然现将数据写入数据库，但是由于某些原因 2 号线程写缓存时优先 1 号线程，最终缓存会存在 1 号线程，写入的数据。此时就会出现脏数据。

### 2、失效模式

![2022-05-16_015502](https://img.qinweizhao.com/2022/05/2022-05-16_015502.png)

1号线程更改数据库后将缓存中的数据删除， 2 号线程去更改数据库中数据，此时（由于某些原因 2 号线程并未将数据写入数据库） 3 号线程去读缓存将会读取 1 号线程写入的值，当 3 号线程更新缓存之前 2 号线程执行了删缓存，之后 3 号线程去更新缓存，最终结果是缓存中的数据为 1 号线程写入数据库中的值，即出现数据不一致问题。

### 3、解决方案

- 加锁

  通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。

- 中间件-canal

  canal 是阿里巴巴开源的一个中间件，它将自己伪装成数据库的从库向 MySQL master 发送dump 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )，canal 解析 binary log 对象(原始为 byte 流)。

### 总结

****

- 我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间， 保证每天拿到当前最新数据即可。

- 不应该过度设计，增加系统的复杂性。

- 遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。
- 优先选择失效模式，简单有效。双写模式麻烦复杂，复杂就容易出错，虽然带来一个查数据库的操作，可能会有缓存击穿问题，但是加锁很容易避免。 
